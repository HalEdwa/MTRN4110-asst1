function [point, normal, fitresult] = getOrientation(c)
%% usage: getOrientation([xData; yData; zData])
    
    %pretty sure this just turns the x, y and z data into 3 vectors instead
    %of matrices
    [fitresult, ~] = fit( [c(1, :)', c(2, :)'], c(3, :)', 'poly11');

    %plane is of the form:
    %z = p00 + p10*x + p01*y
    %I like the form:
    %a*x + b*y + c*z = d
    a = fitresult.p10;
    b = fitresult.p01;
    c = 1;
    d = fitresult.p00;

    %now fit the data back, should be more or less the same as
    %the previos p and n: (the direction of n, not the magnitude)
    normal = [a b -c];
    
    if normal(2) < 0
        %the fit thinks we are not upside down.
        %If we are upside down, there are bigger things to worry about
        normal = -normal;
    end

    %% finding the planept is currently not working as it assupes p is a matrix, not a vector
    point = [0 0 0];
    %find a point more or less in the middle of the plane:
%     [xLen, yLen, ~] = size(p);
%     planePt = squeeze(p(round(xLen/2), round(yLen/2), :));
    %refit z point to be inline with the values generated by the curve fit:
%     point = [planePt(1) planePt(2) (-d - a*planePt(1) - b*planePt(2))/-c];
    
end